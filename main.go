package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

func main() {
	if err := run(); err != nil {
		log.Fatalf("fatal: %+v", err)
	}
}

var tpl = template.Must(template.New("").Parse(`// Code generated by spansloc. DO NOT EDIT.
package {{.Package}}

import "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"

func init() {
	tracer.RegisterSpansLocations(
		{{range .Locations}}tracer.SpanLoc{ "{{.Name}}", "{{.File}}", "{{.Line}}" },
		{{end}}
	)
}
`))

var (
	pkgRegexp       = regexp.MustCompile(`package (.+)`)
	startSpanRegexp = regexp.MustCompile(`tracer.StartSpanFromContext\((.+), "(.+)"(.*)\)`)
)

type SpanLoc struct {
	Name, File string
	Line       int
}
type TplData struct {
	Package   string
	Locations []SpanLoc
}

func run() error {
	path := "."
	if len(os.Args) > 1 {
		log.Printf("arg: %s\n", os.Args[1])
		path = os.Args[1]
	}
	log.Printf("path: %s\n", path)
	lastFolder := ""
	data := TplData{}
	err := filepath.Walk(path, func(p string, f os.FileInfo, err error) error {
		if f.IsDir() {
			return nil
		}
		if filepath.Ext(p) != ".go" || strings.HasSuffix(p, "_test.go") {
			return nil
		}
		abs, err := filepath.Abs(p)
		if err != nil {
			return err
		}
		folder := abs[:len(abs)-len(filepath.Base(abs))]
		if lastFolder == "" {
			lastFolder = folder
		}
		if lastFolder != folder {
			if err := write(data, lastFolder); err != nil {
				return err
			}
			data.Package = ""
			data.Locations = nil
			lastFolder = folder
		}
		b, err := os.ReadFile(abs)
		if err != nil {
			return err
		}
		text := string(b)
		names, lines := extract(text)
		type spanLoc struct {
			Name, File string
			Line       int
		}
		if len(names) == 0 {
			log.Printf("nothing in: %s\n", abs)
			return nil
		}
		log.Printf("found %v in: %s\n", names, abs)
		for i := 0; i < len(names); i++ {
			data.Locations = append(data.Locations, SpanLoc{names[i], abs, lines[i]})
		}
		if data.Package == "" {
			data.Package = pkg(text)
		}
		return nil
	})
	if err := write(data, lastFolder); err != nil {
		return err
	}
	if err != nil {
		return err
	}
	return nil
}

func write(data TplData, folder string) error {
	if data.Package == "" || len(data.Locations) == 0 {
		return nil
	}
	var buf bytes.Buffer
	if err := tpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("tpl execute: %w", err)
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("fmt source: %w\nraw:\n%s", err, string(buf.Bytes()))
	}
	o := filepath.Join(folder, "_dd_spans_locations.go")
	log.Printf("writing %v to %s", data.Locations, o)
	return os.WriteFile(o, formatted, 0644)
}

func pkg(text string) string {
	m := pkgRegexp.FindStringSubmatch(text)
	if m == nil {
		return "TODO"
	}
	return m[1]
}

func extract(text string) ([]string, []int) {
	m := startSpanRegexp.FindAllStringSubmatchIndex(text, -1)
	if m == nil {
		return nil, nil
	}
	names := make([]string, len(m))
	lines := make([]int, len(m))
	for i, element := range m {
		names[i] = text[element[4]:element[5]]
		lines[i] = strings.Count(text[:element[0]], "\n") + 1
	}
	return names, lines
}
