package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

func main() {
	if err := run(); err != nil {
		log.Fatalf("fatal: %+v", err)
	}
}

var tpl = template.Must(template.New("").Parse(`// Code generated by spansloc. DO NOT EDIT.
package TODO

import "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"

func init() {
	tracer.RegisterSpansLocations(
		{{range .}}tracer.SpanLoc{ "{{.Name}}", "{{.File}}", "{{.Line}}" },
		{{end}}
	)
}
`))

var startSpanRegexp = regexp.MustCompile(`tracer.StartSpanFromContext\((.+), "(.+)"(.*)\)`)

func run() error {
	path := "."
	if len(os.Args) > 1 {
		log.Printf("arg: %s\n", os.Args[1])
		path = os.Args[1]
	}
	log.Printf("path: %s\n", path)
	err := filepath.Walk(path, func(p string, f os.FileInfo, err error) error {
		abs, err := filepath.Abs(p)
		if err != nil {
			return err
		}
		log.Printf("abs: %s\n", abs)
		if f.IsDir() {
			log.Printf("excluded: %s\n", p)
			return nil
		}
		if filepath.Ext(p) != ".go" || strings.HasSuffix(p, "_test.go") {
			log.Printf("excluded: %s\n", p)
			return nil
		}
		b, err := os.ReadFile(abs)
		if err != nil {
			return err
		}
		text := string(b)
		names, lines := extract(text)
		type spanLoc struct {
			Name, File string
			Line       int
		}
		if len(names) == 0 {
			log.Printf("nothing in: %s\n", abs)
			return nil
		}
		data := []spanLoc{}
		for i := 0; i < len(names); i++ {
			data = append(data, spanLoc{names[i], abs, lines[i]})
		}
		var buf bytes.Buffer
		if err := tpl.Execute(&buf, data); err != nil {
			return fmt.Errorf("tpl execute: %w", err)
		}
		formatted, err := format.Source(buf.Bytes())
		if err != nil {
			return fmt.Errorf("fmt source: %w\nraw:\n%s", err, string(buf.Bytes()))
		}
		folder := abs[:len(abs)-len(filepath.Base(abs))]
		o := filepath.Join(folder, "_dd_spans_locations.go")
		log.Printf("writing to %s", o)
		return os.WriteFile(o, formatted, 0644)
	})
	if err != nil {
		return err
	}
	return nil
}

func extract(text string) ([]string, []int) {
	m := startSpanRegexp.FindAllStringSubmatchIndex(text, -1)
	if m == nil {
		return nil, nil
	}
	names := make([]string, len(m))
	lines := make([]int, len(m))
	for i, element := range m {
		names[i] = text[element[4]:element[5]]
		lines[i] = strings.Count(text[:element[0]], "\n") + 1
	}
	return names, lines
}
